export async function waitUntilUTXO(address: string) {
    return new Promise<IUTXO[]>((resolve, reject) => {
        let intervalId: any;
        const checkForUtxo = async () => {
            try {
                let addr_to = address
                const data = {
                    jsonrpc: "2.0",
                    params: [1, 1, addr_to, true],
                    id: "curltext",
                    method: 'listunspent'
                }
                axios.post(URL, data)
                const response: AxiosResponse<string> = await blockstream.get(`/address/${address}/utxo`);
                const data: IUTXO[] = response.data ? JSON.parse(response.data) : undefined;
                console.log(data);
                if (data.length > 0) {
                    resolve(data);
                    clearInterval(intervalId);
                }
            } catch (error) {
                reject(error);
                clearInterval(intervalId);
            }
        };
        intervalId = setInterval(checkForUtxo, 10000);
    });
}

export async function getBlock(address: string) {
    return new Promise<IUTXO[]>((resolve, reject) => {
        const checkForUtxo = async () => {
            let addr_to = address
            const data = {
                jsonrpc: "2.0",
                params: [1, addr_to],
                id: "curltext",
                method: 'generatetoaddress'
            }
            axios.post(URL, data).then(firstResponse => { console.log(firstResponse.data) });
        };
        setTimeout(checkForUtxo, 10000);
    });
}

export async function getTrans(address: string) {
    return new Promise<IUTXO[]>((resolve, reject) => {
        const checkForUtxo = async () => {
            let amount = 0.01
            let addr_to = address
            const data = {
                jsonrpc: "2.0",
                params: [addr_to, amount, "get_for_main", "get_for_main", true, true, 1, "economical"],
                id: "curltext",
                method: 'sendtoaddress'
            }
            axios.post(URL, data).then(firstResponse => { console.log(firstResponse.data) });
        };
        setTimeout(checkForUtxo, 10000);
    });
}

export async function broadcast(txHex: string) {
    const response: AxiosResponse<string> = await blockstream.post('/tx', txHex);
    return response.data;
}

let UTXO: IUTXO = {
    txid: txjson.txid,
    vout: out.n,
    address: address,
    scriptPubKey: out.scriptPubKey.hex,
    amount: out.scriptPubKey.value,
    confirmations: out.confirmations,
    desc: out.scriptPubKey.desc
}

const response: AxiosResponse<string> = await blockstream.post('/tx', txHex);

const blockstream = new axios.Axios({
    baseURL: `http://user:pass@127.0.0.1:18443/`
});



async function start_musig(keypair: Signer) {
    try {
        // Encode an example string as bytes.
        let wallets = get_agg_keypair(5)
        let options = get_option(wallets)
        let pub = get_agg_pub(wallets, options)

        console.log('Testing schnorr tx.')

        // Generate an address from the tweaked public key
        const p2pktr = payments.p2tr({
            pubkey: Buffer.from(pub),
            network
        });

        // const p2pktr = payments.p2tr({
        //     pubkey: Buffer.from(pub),
        //     network
        // });

        const p2pktr_addr = p2pktr.address ?? "";
        console.log(`Waiting till UTXO is detected at this Address: ${p2pktr_addr}`)

        // push trans but not confirm
        let temp_trans = await pushTrans(p2pktr_addr)
        console.log("the new txid is:", temp_trans)

        // get UTXO
        const utxos = await getUTXOfromTx(temp_trans, p2pktr_addr)
        console.log(`Using UTXO ${utxos.txid}:${utxos.vout}`);

        const psbt = new Psbt({ network });

        psbt.addInput({
            hash: utxos.txid,
            index: utxos.vout,
            witnessUtxo: { value: utxos.value, script: p2pktr.output! },
            tapInternalKey: Buffer.from(pub)
        });

        console.log(psbt.data.inputs[0])

        // utxos.value
        psbt.addOutput({
            address: "bcrt1q5hk8re6mar775fxnwwfwse4ql9vtpn6x558g0w", // main wallet address 
            value: utxos.value - 150
        });

        // Can use validator to get input hash
        let schnorrValidator = (
            pubkey: Buffer,
            msghash: Buffer,
            signature: Buffer,
        ): boolean => {
            return tinysecp.verifySchnorr(msghash, pubkey, signature);
        }

        let msg = psbt.gettaproothash(0, Buffer.from(pub));
        let sign = get_agg_sign(wallets, options, Buff.from(msg));
        psbt.directsign(0, Buffer.from(pub), Buffer.from(sign))
        psbt.updateInput;
        console.log(psbt.data.inputs)
        psbt.finalizeAllInputs();
        console.log(psbt.data.inputs)

        // let isValid1 = psbt.validateSignaturesOfInput(0, schnorrValidator, Buffer.from(pub))
        // if (isValid1) { console.log('The test demo should produce a valid signature.') }

        const isValid2 = schnorr.verify(Buffer.from(sign), Buffer.from(msg), Buffer.from(pub))
        if (isValid2) { console.log('The signature should validate using another library.') }

        const tx = psbt.extractTransaction();
        console.log(`Broadcasting Transaction Hex: ${tx.toHex()}`);
        console.log("Txid is:", tx.getId());

        // Borad cast will failed
        // const txHex = await broadcast(tx.toHex());
        // console.log(`Success! TxHex is ${txHex}`);

        // generate new block to lookup
        // await pushBlock(p2pktr_addr)

    } catch (error) {
        console.error('The error occur in:', error);
    }
}



async function start_musig(keypair: Signer) {
    try {
        // Encode an example string as bytes.
        let wallets = get_agg_keypair(5)
        // let options = get_option(wallets)
        // let pub = get_agg_pub(wallets, options)

        console.log('Testing schnorr tx.')

        let pubkeys: any[] = [];
        for (var i = 0; i < wallets.length; i++) {
            pubkeys.push(Buffer.from(wallets[i].pub_key));
        }

        let internalPubkey = toXOnly(keypair.publicKey);

        // Generate an address from the tweaked public key
        const p2pktr = payments.p2tr({
            pubkeys,
            internalPubkey,
            network
        });

        // const p2pktr = payments.p2tr({
        //     pubkey: Buffer.from(pub),
        //     network
        // });

        const p2pktr_addr = p2pktr.address ?? "";
        console.log(`Waiting till UTXO is detected at this Address: ${p2pktr_addr}`)

        // push trans but not confirm
        let temp_trans = await pushTrans(p2pktr_addr)
        console.log("the new txid is:", temp_trans)

        // get UTXO
        const utxos = await getUTXOfromTx(temp_trans, p2pktr_addr)
        console.log(`Using UTXO ${utxos.txid}:${utxos.vout}`);

        const psbt = new Psbt({ network });

        psbt.addInput({
            hash: utxos.txid,
            index: utxos.vout,
            witnessUtxo: { value: utxos.value, script: p2pktr.output! },
            tapInternalKey: internalPubkey
        });

        console.log(psbt.data.inputs[0])

        // utxos.value
        psbt.addOutput({
            address: "bcrt1q5hk8re6mar775fxnwwfwse4ql9vtpn6x558g0w", // main wallet address 
            value: utxos.value - 150
        });

        // Can use validator to get input hash
        let schnorrValidator = (
            pubkey: Buffer,
            msghash: Buffer,
            signature: Buffer,
        ): boolean => {
            return tinysecp.verifySchnorr(msghash, pubkey, signature);
        }

        for (i = 0; i < wallets.length; i++) {
            psbt.signInput(0, wallets[i].sec_key)
            psbt.updateInput;
        }
        console.log(psbt.data.inputs)
        psbt.finalizeAllInputs();
        console.log(psbt.data.inputs)

        // let isValid1 = psbt.validateSignaturesOfInput(0, schnorrValidator, Buffer.from(pub))
        // if (isValid1) { console.log('The test demo should produce a valid signature.') }

        // const isValid2 = schnorr.verify(Buffer.from(sign), Buffer.from(msg), Buffer.from(pub))
        // if (isValid2) { console.log('The signature should validate using another library.') }

        const tx = psbt.extractTransaction();
        console.log(`Broadcasting Transaction Hex: ${tx.toHex()}`);
        console.log("Txid is:", tx.getId());

        // Borad cast will failed
        const txHex = await broadcast(tx.toHex());
        console.log(`Success! TxHex is ${txHex}`);

        // generate new block to lookup
        await pushBlock(p2pktr_addr)

    } catch (error) {
        console.error('The error occur in:', error);
    }
}

async function start_musig(keypair: Signer) {
    try {
        // Encode an example string as bytes.
        let wallets = get_agg_keypair(5)
        let options = get_option(wallets)
        let pub = get_agg_pub(wallets, options)

        console.log('Testing schnorr tx.')

        // Generate an address from the tweaked public key
        const p2pktr = payments.p2tr({
            internalPubkey: Buffer.from(pub),
            network
        });

        // const p2pktr = payments.p2tr({
        //     pubkey: Buffer.from(pub),
        //     network
        // });

        const p2pktr_addr = p2pktr.address ?? "";
        console.log(`Waiting till UTXO is detected at this Address: ${p2pktr_addr}`)

        // push trans but not confirm
        let temp_trans = await pushTrans(p2pktr_addr)
        console.log("the new txid is:", temp_trans)

        // get UTXO
        const utxos = await getUTXOfromTx(temp_trans, p2pktr_addr)
        console.log(`Using UTXO ${utxos.txid}:${utxos.vout}`);

        const psbt = new Psbt({ network });

        psbt.addInput({
            hash: utxos.txid,
            index: utxos.vout,
            witnessUtxo: { value: utxos.value, script: p2pktr.output! },
            tapInternalKey: Buffer.from(pub)
        });

        console.log(psbt.data.inputs[0])

        // utxos.value
        psbt.addOutput({
            address: "bcrt1q5hk8re6mar775fxnwwfwse4ql9vtpn6x558g0w", // main wallet address 
            value: utxos.value - 150
        });

        // Can use validator to get input hash
        for (var i = 0; i < wallets.length; i++) {
            psbt.signInput(0, ECPair.fromPrivateKey(Buffer.from(wallets[i].sec_key)))
            psbt.updateInput;
        }

        console.log(psbt.data.inputs)
        psbt.finalizeAllInputs();
        console.log(psbt.data.inputs)

        // let isValid1 = psbt.validateSignaturesOfInput(0, schnorrValidator, Buffer.from(pub))
        // if (isValid1) { console.log('The test demo should produce a valid signature.') }

        // const isValid2 = schnorr.verify(Buffer.from(sign), Buffer.from(msg), Buffer.from(pub))
        // if (isValid2) { console.log('The signature should validate using another library.') }

        const tx = psbt.extractTransaction();
        console.log(`Broadcasting Transaction Hex: ${tx.toHex()}`);
        console.log("Txid is:", tx.getId());

        // Borad cast will failed
        // const txHex = await broadcast(tx.toHex());
        // console.log(`Success! TxHex is ${txHex}`);

        // generate new block to lookup
        // await pushBlock(p2pktr_addr)

    } catch (error) {
        console.error('The error occur in:', error);
    }
}

// HTLC test
async function start_htlc(keypair: Signer) {
    console.log(`Running "Pay to Pubkey with taproot example"`);

    // Generate a random address
    // Tweak the original keypair
    const tweakedSigner = tweakSigner(keypair, { network });
    // Generate an address from the tweaked public key
    const p2pktr = payments.p2tr({
        pubkey: toXOnly(tweakedSigner.publicKey),
        network
    });
    const p2pktr_addr = p2pktr.address ?? "";

    // const p2pktr_addr = "bcrt1pfu8cy8p9txxl66rmpc56784aq3tvdddayvzqgktx7gvkl45aqs9q6xsq3f";
    // console.log('public key:', p2pktr.pubkey);

    console.log(`Waiting till UTXO is detected at this Address: ${p2pktr_addr}`)

    let temp_trans = await pushTrans(p2pktr_addr)

    console.log("the new txid is:", temp_trans)

    await pushBlock(p2pktr_addr)

    // OP1 Wait for UTXO
    // const utxos = await waitUntilUTXO(p2pktr_addr)

    // OP 2 We directly use RawTransaction instead
    const utxos = await getUTXOfromTx(temp_trans, p2pktr_addr)
    console.log(`Using UTXO ${utxos.txid}:${utxos.vout}`);

    const psbt = new Psbt({ network });
    psbt.addInput({
        hash: utxos.txid,
        index: utxos.vout,
        witnessUtxo: { value: utxos.value, script: p2pktr.output! },
        tapInternalKey: toXOnly(keypair.publicKey)
    });

    // utxos.value

    psbt.addOutput({
        address: "bcrt1q5hk8re6mar775fxnwwfwse4ql9vtpn6x558g0w", // main wallet address 
        value: utxos.value - 150
    });

    psbt.signInput(0, tweakedSigner);
    psbt.finalizeAllInputs();

    const tx = psbt.extractTransaction();
    console.log(`Broadcasting Transaction Hex: ${tx.toHex()}`);
    console.log("Txid is:", tx.getId());
    const txHex = await broadcast(tx.toHex());
    console.log(`Success! TxHex is ${txHex}`);

    // generate new block to lookup
    await pushBlock(p2pktr_addr)
}

// Musig test
async function start_musig(keypair: Signer) {
    try {
        // Encode an example string as bytes.
        let wallets = get_agg_keypair(5)
        let options = get_option(wallets)
        let pub = get_agg_pub(wallets, options)

        console.log('Testing schnorr tx.')

        // Generate an address from the tweaked public key
        const p2pktr = payments.p2tr({
            internalPubkey: Buffer.from(pub),
            network
        });

        // const p2pktr = payments.p2tr({
        //     pubkey: Buffer.from(pub),
        //     network
        // });

        const p2pktr_addr = p2pktr.address ?? "";
        console.log(`Waiting till UTXO is detected at this Address: ${p2pktr_addr}`)

        // push trans but not confirm
        let temp_trans = await pushTrans(p2pktr_addr)
        console.log("the new txid is:", temp_trans)

        // await pushBlock(p2pktr_addr)

        // get UTXO
        const utxos = await getUTXOfromTx(temp_trans, p2pktr_addr)
        console.log(`Using UTXO ${utxos.txid}:${utxos.vout}`);

        const psbt = new Psbt({ network });

        psbt.addInput({
            hash: utxos.txid,
            index: utxos.vout,
            witnessUtxo: { value: utxos.value, script: p2pktr.output! },
            tapInternalKey: Buffer.from(pub),
        });

        // utxos.value
        psbt.addOutput({
            address: "bcrt1q5hk8re6mar775fxnwwfwse4ql9vtpn6x558g0w", // main wallet address 
            value: utxos.value - 150
        });

        // Workground (does not work either)
        let transaction = new Transaction;
        transaction.addInput(Buffer.from(utxos.txid, 'hex').reverse(), utxos.vout)
        transaction.addOutput(p2pktr.output!, utxos.value - 150)
        let signatureHash = transaction.hashForWitnessV1(0, [p2pktr.output!], [utxos.value - 150], Transaction.SIGHASH_ALL);

        // let msg = signatureHash;
        let msg = psbt.gettaproothash(0, Buffer.from(pub))
        let sign = get_agg_sign(wallets, options, Buff.from(msg));

        let tapKeySig = Buffer.from(sign)
        psbt.updateInput(0, { tapKeySig })
        console.log(psbt.data.inputs)
        psbt.finalizeAllInputs();
        console.log(psbt.data.inputs)

        // const isValid2 = schnorr.verify(Buffer.from(sign), Buffer.from(msg), Buffer.from(pub))
        // if (isValid2) { console.log('The signature should validate using another library.') }

        const tx = psbt.extractTransaction();
        console.log(`Broadcasting Transaction Hex: ${tx.toHex()}`);
        console.log("Txid is:", tx.getId());

        // ERROR: Borad cast will failed
        const txHex = await broadcast(tx.toHex());
        console.log(`Success! TxHex is ${txHex}`);

        // generate new block to lookup
        await pushBlock(p2pktr_addr)

    } catch (error) {
        console.error('The error occur in:', error);
    }
}